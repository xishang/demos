package com.demos.java.designpatterns.behavioral.iterator;

/**
 * @author xishang
 * @version 1.0
 * @date 2018/1/9
 * <p>
 * 迭代器模式: 提供一种方法来访问聚合对象, 而不用暴露这个对象的内部表示
 * 概念:
 * => 宽接口: 聚集的接口提供了可以用来修改聚集元素的方法, 这样的接口就是宽接口
 * => 窄接口: 聚集的接口没有提供修改聚集元素的方法, 这样的接口就是窄接口
 * 迭代子模式:
 * => 白箱聚集与外禀迭代子: 提供宽接口的聚集, 白箱聚集向外界提供访问自己内部元素的接口, 从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能
 * => 黑箱聚集与内禀迭代子: 聚集对象为迭代子对象提供一个宽接口, 而为其他对象提供一个窄接口, 使其他对象通过迭代子对象进行进行遍历操作(JDK集合的迭代子模式)
 * 主动迭代子和被动迭代子:
 * => 主动迭代子: 由客户端来控制迭代下一个元素的步骤, 如: next()迭代方法, 在遍历过程中向前进行
 * => 被动迭代子: 由迭代子自己来控制迭代下一个元素的步骤, 客户端需要把操作传递给迭代子, 类似于回调机制(Iterable.forEach)
 * 静态迭代子和动态迭代子:
 * => 静态迭代子: 静态迭代子由聚集对象创建, 并持有聚集对象的一份快照(snapshot), 在产生后这个快照的内容就不再变化
 * => 动态迭代子: 迭代子保持着对聚集元素的引用, 任何对原聚集内容的修改都会在迭代子对象上反映出来
 * Fail Fast: 一个算法开始之后, 它的运算环境发生变化, 使得算法无法进行必需的调整时, 这个算法就应当立即发出故障信号
 * <p>
 * 优点: 将遍历数据操作从聚集对象中分离出来, 聚集对象只负责存储数据, 符合"单一职责原则", 同时简化了聚合类的设计
 * 典型应用: Java集合类
 * <p>
 * 抽象迭代器
 */
public interface Iterator<E> {

    boolean hasNext();

    E next();

}
